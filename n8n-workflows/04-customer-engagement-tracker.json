{
  "name": "Customer Engagement Tracker - Churn Prevention",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours",
              "hoursInterval": 4
            }
          ]
        }
      },
      "id": "trigger-schedule",
      "name": "Run Every 4 Hours",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.1,
      "position": [250, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  id,\n  customer_id,\n  customer_name,\n  content,\n  sentiment,\n  urgency_score,\n  direction,\n  created_at\nFROM mottivme_intelligence_system.messages\nWHERE created_at >= NOW() - INTERVAL '30 days'\nORDER BY customer_id, created_at",
        "options": {}
      },
      "id": "get-messages-30d",
      "name": "Get Messages (30 days)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [450, 300],
      "credentials": {
        "postgres": {
          "id": "w2mBaRwhZ3tM4FUw",
          "name": "Postgres Marcos Daniels."
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Calculate customer engagement and churn risk\nconst messages = $input.all();\n\n// Group by customer\nconst customerMap = {};\nmessages.forEach(m => {\n  const customerId = m.json.customer_id;\n  if (!customerId) return;\n  \n  if (!customerMap[customerId]) {\n    customerMap[customerId] = {\n      customer_id: customerId,\n      customer_name: m.json.customer_name || customerId,\n      messages: [],\n      sentiments: [],\n      urgencyScores: []\n    };\n  }\n  \n  customerMap[customerId].messages.push(m.json);\n  if (m.json.sentiment) customerMap[customerId].sentiments.push(m.json.sentiment);\n  if (m.json.urgency_score) customerMap[customerId].urgencyScores.push(m.json.urgency_score);\n});\n\nconst today = new Date();\nconst todayStr = today.toISOString().split('T')[0];\nconst results = [];\n\nObject.values(customerMap).forEach(customer => {\n  const msgs = customer.messages;\n  const sentiments = customer.sentiments;\n  \n  const sentCount = msgs.filter(m => m.direction === 'outbound').length;\n  const receivedCount = msgs.filter(m => m.direction === 'inbound').length;\n  \n  const sortedMsgs = msgs.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));\n  const lastInteraction = sortedMsgs[0]?.created_at;\n  const daysSinceContact = lastInteraction \n    ? Math.floor((today - new Date(lastInteraction)) / (1000 * 60 * 60 * 24))\n    : 30;\n  \n  const avgResponseTime = 24;\n  \n  const negativeSentiments = sentiments.filter(s => s === 'negative' || s === 'angry').length;\n  const negativeRatio = sentiments.length > 0 ? negativeSentiments / sentiments.length : 0;\n  const highUrgencyCount = customer.urgencyScores.filter(u => u >= 7).length;\n  \n  const volumeScore = Math.min(30, msgs.length * 2);\n  let recencyScore = 30;\n  if (daysSinceContact > 7) recencyScore = 20;\n  if (daysSinceContact > 14) recencyScore = 10;\n  if (daysSinceContact > 21) recencyScore = 5;\n  if (daysSinceContact > 28) recencyScore = 0;\n  \n  const responseRatio = sentCount > 0 ? receivedCount / sentCount : 0;\n  const responseScore = Math.min(20, responseRatio * 20);\n  const sentimentScore = Math.max(0, 20 - (negativeRatio * 40));\n  const engagementScore = Math.round(volumeScore + recencyScore + responseScore + sentimentScore);\n  \n  let churnRisk = 0;\n  churnRisk += Math.min(40, daysSinceContact * 2);\n  churnRisk += Math.round(negativeRatio * 30);\n  churnRisk += Math.min(20, highUrgencyCount * 5);\n  if (engagementScore < 30) churnRisk += 10;\n  churnRisk = Math.min(100, churnRisk);\n  \n  let healthStatus = 'healthy';\n  if (churnRisk >= 60) healthStatus = 'critical';\n  else if (churnRisk >= 30) healthStatus = 'at_risk';\n  \n  results.push({\n    json: {\n      customer_id: customer.customer_id,\n      customer_name: customer.customer_name,\n      date: todayStr,\n      messages_sent: sentCount,\n      messages_received: receivedCount,\n      response_time_avg_hours: avgResponseTime,\n      engagement_score: engagementScore,\n      health_status: healthStatus,\n      churn_risk_score: churnRisk,\n      last_interaction: lastInteraction || null,\n      days_since_last_contact: daysSinceContact\n    }\n  });\n});\n\nreturn results.length > 0 ? results : [{ json: { skip: true, reason: 'No customer data' } }];"
      },
      "id": "calculate-engagement",
      "name": "Calculate Customer Engagement",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [650, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "check-skip",
              "leftValue": "={{ $json.skip }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "notEquals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-has-data",
      "name": "Has Data?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [850, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO mottivme_intelligence_system.customer_engagement (\n  customer_id, customer_name, date, messages_sent, messages_received,\n  response_time_avg_hours, engagement_score, health_status,\n  churn_risk_score, last_interaction, days_since_last_contact\n) VALUES (\n  '{{ $json.customer_id }}',\n  '{{ $json.customer_name }}',\n  '{{ $json.date }}'::date,\n  {{ $json.messages_sent }},\n  {{ $json.messages_received }},\n  {{ $json.response_time_avg_hours }},\n  {{ $json.engagement_score }},\n  '{{ $json.health_status }}',\n  {{ $json.churn_risk_score }},\n  {{ $json.last_interaction ? \"'\" + $json.last_interaction + \"'::timestamptz\" : \"NULL\" }},\n  {{ $json.days_since_last_contact }}\n)\nON CONFLICT (customer_id, date) DO UPDATE SET\n  customer_name = EXCLUDED.customer_name,\n  messages_sent = EXCLUDED.messages_sent,\n  messages_received = EXCLUDED.messages_received,\n  engagement_score = EXCLUDED.engagement_score,\n  health_status = EXCLUDED.health_status,\n  churn_risk_score = EXCLUDED.churn_risk_score,\n  last_interaction = EXCLUDED.last_interaction,\n  days_since_last_contact = EXCLUDED.days_since_last_contact,\n  updated_at = NOW()\nRETURNING id",
        "options": {}
      },
      "id": "upsert-engagement",
      "name": "Upsert Customer Engagement",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [1050, 250],
      "credentials": {
        "postgres": {
          "id": "w2mBaRwhZ3tM4FUw",
          "name": "Postgres Marcos Daniels."
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "check-critical",
              "leftValue": "={{ $json.health_status }}",
              "rightValue": "critical",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-critical",
      "name": "Is Critical?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1050, 400]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO mottivme_intelligence_system.alerts (\n  alert_type, severity, title, message, source, metadata, status\n) VALUES (\n  'churn_risk',\n  'high',\n  'Cliente em Risco: {{ $json.customer_name }}',\n  'Risco de churn {{ $json.churn_risk_score }}%. Ultimo contato ha {{ $json.days_since_last_contact }} dias. Engajamento: {{ $json.engagement_score }}/100.',\n  'sentinel_engagement_tracker',\n  '{\"customer_id\": \"{{ $json.customer_id }}\", \"churn_risk\": {{ $json.churn_risk_score }}, \"engagement_score\": {{ $json.engagement_score }}}'::jsonb,\n  'pending'\n) RETURNING id",
        "options": {}
      },
      "id": "create-alert",
      "name": "Create Critical Alert",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [1250, 400],
      "credentials": {
        "postgres": {
          "id": "w2mBaRwhZ3tM4FUw",
          "name": "Postgres Marcos Daniels."
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const engagements = $input.all();\nconst criticalCount = engagements.filter(e => e.json.health_status === 'critical').length;\nconst atRiskCount = engagements.filter(e => e.json.health_status === 'at_risk').length;\nconst healthyCount = engagements.filter(e => e.json.health_status === 'healthy').length;\nconst avgEngagement = engagements.length > 0 ? engagements.reduce((sum, e) => sum + (e.json.engagement_score || 0), 0) / engagements.length : 0;\nconst avgChurnRisk = engagements.length > 0 ? engagements.reduce((sum, e) => sum + (e.json.churn_risk_score || 0), 0) / engagements.length : 0;\nconst today = new Date().toISOString();\n\nreturn [{\n  json: {\n    insight_type: 'cs_engagement_summary',\n    content: `Resumo CS ${today.split('T')[0]}: ${engagements.length} clientes. ${criticalCount} criticos, ${atRiskCount} em risco, ${healthyCount} saudaveis. Engajamento medio: ${avgEngagement.toFixed(1)}/100. Risco medio: ${avgChurnRisk.toFixed(1)}%.`,\n    confidence_score: 1.0,\n    metadata: JSON.stringify({ total_customers: engagements.length, critical: criticalCount, at_risk: atRiskCount, healthy: healthyCount, avg_engagement: avgEngagement, avg_churn_risk: avgChurnRisk, analyzed_at: today }),\n    processed_for_kb: true\n  }\n}];"
      },
      "id": "generate-summary",
      "name": "Generate CS Summary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1450, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO mottivme_intelligence_system.sentinel_insights (insight_type, content, confidence_score, metadata, processed_for_kb)\nVALUES ('{{ $json.insight_type }}', '{{ $json.content }}', {{ $json.confidence_score }}, '{{ $json.metadata }}'::jsonb, {{ $json.processed_for_kb }})\nRETURNING id",
        "options": {}
      },
      "id": "save-summary",
      "name": "Save CS Summary",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [1650, 300],
      "credentials": {
        "postgres": {
          "id": "w2mBaRwhZ3tM4FUw",
          "name": "Postgres Marcos Daniels."
        }
      }
    }
  ],
  "connections": {
    "Run Every 4 Hours": {
      "main": [[{ "node": "Get Messages (30 days)", "type": "main", "index": 0 }]]
    },
    "Get Messages (30 days)": {
      "main": [[{ "node": "Calculate Customer Engagement", "type": "main", "index": 0 }]]
    },
    "Calculate Customer Engagement": {
      "main": [[{ "node": "Has Data?", "type": "main", "index": 0 }]]
    },
    "Has Data?": {
      "main": [[{ "node": "Upsert Customer Engagement", "type": "main", "index": 0 }, { "node": "Is Critical?", "type": "main", "index": 0 }]]
    },
    "Upsert Customer Engagement": {
      "main": [[{ "node": "Generate CS Summary", "type": "main", "index": 0 }]]
    },
    "Is Critical?": {
      "main": [[{ "node": "Create Critical Alert", "type": "main", "index": 0 }]]
    },
    "Generate CS Summary": {
      "main": [[{ "node": "Save CS Summary", "type": "main", "index": 0 }]]
    }
  },
  "settings": { "executionOrder": "v1" },
  "meta": { "instanceId": "mis-sentinel" },
  "tags": [{ "name": "SENTINEL" }, { "name": "CS" }, { "name": "Engagement" }]
}
